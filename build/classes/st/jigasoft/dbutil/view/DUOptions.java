/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package st.jigasoft.dbutil.view;

import st.jigasoft.dbutil.util.models.ItemStateChange;
import st.jigasoft.dbutil.util.models.ProprietValueChange;
import java.awt.Color;
import java.awt.GridLayout;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 *
 * @author Servidor
 */
public class DUOptions<T> extends javax.swing.JPanel implements OptionItem.ItemClick<T>
{
    private final LinkedHashMap<String, OptionItem> optionMap;
    private OptionPosition orientation;
    private Color seletedColor;
    private Color unSeletedColor;
    private Color seletedTextColor;
    private Color unSeletedTextColor;
    private Color mousePointed;
    private int dividerSize;
    private final GridLayout layout;
    private boolean applyDivider;
    private ModoSelection modoSelection;
    private boolean unselecctAll;
    private ItemStateChange<ItemOption<T>, Boolean> onStateChange;
    private ProprietValueChange<ItemOption<T>> onValueChange;
    
    /**
     * Creates new form DUOptions
     */
    public DUOptions()
    {
        initComponents();
        this.optionMap = new  LinkedHashMap<>();
        this.unSeletedColor = Color.decode("#A6A6A6");
        this.unSeletedTextColor = Color.decode("#FFFFFF");
        this.seletedColor = Color.decode("#4682B4");
        this.seletedTextColor =  Color.decode("#FFFFFF");
        this.mousePointed = Color.decode("#3EABFE");
        this.dividerSize = 1;
        this.modoSelection = ModoSelection.RADIO;
        this.setLayout(this.layout = new java.awt.GridLayout(1, 1, 1, 0));
        this.orientation = OptionPosition.HORIZONTAL;
    }
    
    /**
     * Adicionar uma nova ocao a lista
     * @param optKey O codigo da opcao
     * @param optName O valor da opcao
     * @return 
     */
    public ItemOption<T> addOption (String optKey, String optName)
    {   
        OptionItem item;
        OptionItem result = optionMap.putIfAbsent(optKey, item = new OptionItem(this, optKey, optName));
        if(result != null) return null;
        
        item.setColor(this.unSeletedColor);
        item.setColorTitle(this.unSeletedTextColor);
        item.setMousePointed(mousePointed);
        
        
        if(this.orientation == OptionPosition.VERTICAL)
        {
            this.layout.setRows(this.optionMap.size());
            this.layout.setColumns(1);
        } 
        else
        {
             this.layout.setRows(1);
            this.layout.setColumns(this.optionMap.size());
        }
        
        if(this.optionMap.size() > 1)
            this.applyDivider(true);
        this.add(item);
        item.setSize(this.getSize());
        return item;
    }
    
    public void applyDivider(boolean apply)
    {
        if(apply && this.orientation == OptionPosition.VERTICAL)
            this.layout.setVgap(this.dividerSize);
        else if(apply && this.orientation == OptionPosition.HORIZONTAL)
            this.layout.setHgap(this.dividerSize);
        else
        {
            this.layout.setHgap(0);
            this.layout.setVgap(0);
        }
        this.applyDivider = apply;
    }

    public int getDividerSize() {
        return dividerSize;
    }

    public void setDividerSize(int dividerSize)
    {
        this.dividerSize = dividerSize;
        this.applyDivider(this.applyDivider);
    }

    public boolean isApplyDivider()
    {
        return applyDivider;
    }
    
    
    public ItemOption<T> []addOptionsChose(String ... options)
    {
        if(options == null) return  null;
        ItemOption<T>[] items = new ItemOption[options.length];
        int iCount = 0;
        for(String s: options)
        {
            items [iCount++] = this.addOption(s, s);
        }
        
        return items;
    }
    
   
    public ModoSelection getModoSelection()
    {
        return modoSelection;
    }
    
    public void setModoSelection(ModoSelection selection)
    {
        this.modoSelection = selection;
        switch(this.modoSelection)
        {
            case RADIO:
                break;
            case CHECK:
                break;
            case SAMPLES:
                break;
        }
    }
    
    
    
    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        setBorder(new javax.swing.border.LineBorder(new java.awt.Color(0, 0, 0), 1, true));

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 192, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 46, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    public void clear() 
    {
        this.optionMap.clear();
        this.removeAll();
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    public static enum OptionPosition
    {
        VERTICAL,
        HORIZONTAL
    }


    public OptionPosition getOrientation() {
        return orientation;
    }

    public void setOrientation(OptionPosition orientation) {
        this.orientation = orientation;
    }

    public Color getSeletedColor() {
        return seletedColor;
    }

    public void setSeletedColor(Color seletedColor) {
        this.seletedColor = seletedColor;
    }

    public Color getUnSeletedColor() {
        return unSeletedColor;
    }

    public void setUnSeletedColor(Color unSeletedColor) {
        this.unSeletedColor = unSeletedColor;
    }

    public Color getSeletedTextColor() {
        return seletedTextColor;
    }

    public void setSeletedTextColor(Color seletedTextColor)
    {
        this.seletedTextColor = seletedTextColor;
    }

    public Color getUnSeletedTextColor() {
        return unSeletedTextColor;
    }

    public void setUnSeletedTextColor(Color unSeletedTextColor) 
    {
        this.unSeletedTextColor = unSeletedTextColor;
    }
    
    public void select(String itenKey, String ... args)
    {
        this.setSelected(itenKey, true, args);
    }
    
    public void unSelect(String itemKey)
    {
        this.setSelected(itemKey, false);
    }

    public Color getMousePointed() {
        return mousePointed;
    }
    
    

    public void setMousePointed(Color mousePointed) {
        this.mousePointed = mousePointed;
        for(Map.Entry<String, OptionItem> i:this.optionMap.entrySet())
            i.getValue().setMousePointed(mousePointed);
    }
    
    /**
     * Definir o evento para quando o estado da selecoa mudar
     * @param itenKey
     * @param onSelection 
     */
    public void setOnSelectionChange(String itenKey, OptionItem.ItemSelection<T> onSelection)
    {
        OptionItem iten = this.optionMap.get(itenKey);
        if(iten != null) iten.setOnSelectionChange(onSelection);
    }
    
    
    public void unSelectAll()
    {
        System.err.println("Unselect ALL");
        this.unselecctAll = true;
        this.optionMap.entrySet().stream().forEach((i) -> 
        {
            this.setSelected(i.getKey(), false);
        });
        this.unselecctAll = false;
    }
    
    public void setSelected(String itenKey, boolean select, String ... args)
    {
        OptionItem item = this.optionMap.get(itenKey);
        if(item != null && select)
        {
            //QUANDO FOR O MODO RADIO DESATIVAR TODOS OS ANTIGOS QUE ESTEJAM ACTIVIOS
            if(this.modoSelection == ModoSelection.RADIO)
            {
                for(Map.Entry<String, OptionItem> i:this.optionMap.entrySet())
                {
                    if(i.getValue().isSeleted())
                    {
                        this.setSelected(i.getKey(), false);
                        break;
                    }
                }
            }
            
            
            item.setColor(seletedColor);
            item.setColorTitle(seletedTextColor);
            item.setSeleted(true, args);
        }
        else if(item != null  && !select)
        {
            item.setColor(unSeletedColor);
            item.setColorTitle(unSeletedTextColor);
            item.setSeleted(false, args);
        }
    }
    
    public ItemOption<T> getSelectedItem()
    {
        OptionItem<T>[] array = this.findSelecteds();
        if(array.length != 1) return null;
        else return array[0];
    }
    
    /**
     *
     * @return
     */
    public OptionItem<T>[] findSelecteds()
    {
        ArrayList<OptionItem<T>> list = new ArrayList<> ();
        this.optionMap.entrySet().stream().filter((i) -> (i.getValue().isSeleted())).forEach((i) -> {
            list.add(i.getValue());
        });
       OptionItem<T> array [] = new OptionItem [list.size()];
        int count = 0;
       for(OptionItem<T> i:list)
           array[count++]= i;
       return array;
    }
    
    /**
     * Verificar se uma opcao esta selecionada
     * @param optinoKey
     * @return 
     */
    public boolean isSelected(String optinoKey)
    {
        if(optinoKey == null) return false;
        return this.optionMap.entrySet().stream().anyMatch((i) -> (i.getKey().equals(optinoKey)
                && i.getValue().isSelected()));
    }
    
    /**
     * Capaturar a alteracao dos estados de todas as opcoes
     * @param onStateChange
     */
    public void setOnItemStateChange (ItemStateChange<ItemOption<T>, Boolean> onStateChange)
    {
        this.onStateChange = onStateChange;
    }
    
    /**
     * Quando o valor for alterado
     * @param onValueChange 
     */
    public void setOnValueChange(ProprietValueChange<ItemOption<T>> onValueChange)
    {
        this.onValueChange = onValueChange;
    }
    
    public void setEnabled(String optKey, boolean enable)
    {
        if(optKey == null) return;
        
        for (Map.Entry<String, OptionItem> i : this.optionMap.entrySet()) {
            if(i.getKey().equals(optKey))
            {
                i.getValue().setEnabled(enable);
                return;
            }
        }
    }
    
    /**
     * Verificar se ha algum item selecionado
     * @return 
     */
    public boolean hasSelectedItem()
    {
        for(Map.Entry<String, OptionItem> i:this.optionMap.entrySet())
            if(i.getValue().isSelected()) return true;
        return false;
    }

    /**
     *
     * @param item
     * @param currentSelection
     */
    @Override
    public void click(OptionItem<T> item, Boolean currentSelection) 
    {
        ItemOption<T> currentItem = this.getSelectedItem();
        
        if(this.modoSelection == ModoSelection.RADIO)
            currentItem = this.getSelectedItem();
        
        boolean newState = unselecctAll? false
                : (this.modoSelection == ModoSelection.RADIO)? true 
                : !currentSelection;
        
        //Para os modos radio e chekes alterar os seu estado
        if(this.modoSelection == ModoSelection.RADIO
                || this.modoSelection == ModoSelection.CHECK) 
            this.setSelected(item.getKey(),  newState);
        else item.setTemporaryBackgarund(this.seletedColor);
        
        if(newState != currentSelection)
        {
            if(onStateChange != null)
                this.onStateChange.stateChange(item, currentSelection, newState);
            if(onValueChange != null)
                this.onValueChange.valueChange(currentItem, item);
        }
            
    }
    
    public ItemOption<T> getIten(String key)
    {
        return this.optionMap.get(key);
    }
    
    
    public static enum ModoSelection
    {
        /**
         * Permite apenas uma seleção a cada momento
         * Selecao unica em cada momento
         */
        RADIO,
        
        /**
         * Permite mais de uma selecao num dado memento
         */
        CHECK,
        
        SAMPLES
    }
}
